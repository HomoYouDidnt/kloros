"""
Bluetooth Audio Management for KLoROS Voice Assistant
Handles Sony SRS-X3 integration with BlueZ D-Bus API and PipeWire/ALSA routing
"""

import subprocess
import time
import logging
from typing import Optional, List, Dict, Any
from dataclasses import dataclass
from enum import Enum
import threading

try:
    from pydbus import SessionBus, SystemBus
    PYDBUS_AVAILABLE = True
except ImportError:
    PYDBUS_AVAILABLE = False
    logging.warning("pydbus not available - falling back to subprocess calls")

@dataclass
class BluetoothDevice:
    """Represents a Bluetooth audio device"""
    address: str
    name: str
    alias: str
    paired: bool = False
    connected: bool = False
    trusted: bool = False
    audio_sink: bool = False
    audio_source: bool = False

class ConnectionState(Enum):
    """Bluetooth connection states"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    FAILED = "failed"
    UNKNOWN = "unknown"

class BluetoothAudioManager:
    """
    Modern Bluetooth audio management for KLoROS with Sony SRS-X3 integration
    Uses BlueZ D-Bus API with ALSA/PipeWire fallback for audio routing
    """

    SONY_SRS_X3_ADDRESS = "0C:A6:94:73:41:8E"  # From bluetoothctl devices output
    SONY_SRS_X3_NAME = "SONY:SRS-X3"

    def __init__(self, logger: Optional[logging.Logger] = None):
        self.logger = logger or logging.getLogger(__name__)
        self.connection_state = ConnectionState.UNKNOWN
        self._connection_lock = threading.Lock()

        # D-Bus setup
        self._system_bus = None
        self._bluetooth_adapter = None
        self._setup_dbus()

        # Audio routing method preference
        self.audio_methods = ['wpctl', 'pactl', 'aplay']  # Preference order
        self.active_audio_method = None

    def _setup_dbus(self) -> None:
        """Initialize D-Bus connection to BlueZ"""
        try:
            if not PYDBUS_AVAILABLE:
                self.logger.warning("D-Bus unavailable, using subprocess fallback")
                return

            self._system_bus = SystemBus()

            # Get Bluetooth adapter
            try:
                adapter_path = "/org/bluez/hci0"
                self._bluetooth_adapter = self._system_bus.get("org.bluez", adapter_path)
                self.logger.info("Connected to BlueZ D-Bus adapter")
            except Exception as e:
                self.logger.error(f"Failed to connect to BlueZ adapter: {e}")

        except Exception as e:
            self.logger.error(f"Failed to setup D-Bus: {e}")

    def discover_devices(self, timeout: int = 10) -> List[BluetoothDevice]:
        """Discover available Bluetooth devices"""
        devices = []

        try:
            # Use subprocess fallback for reliability
            result = subprocess.run(['bluetoothctl', 'devices'],
                                  capture_output=True, text=True, timeout=5)

            if result.returncode == 0:
                for line in result.stdout.strip().split('\n'):
                    if line.startswith('Device'):
                        parts = line.split(' ', 2)
                        if len(parts) >= 3:
                            address = parts[1]
                            name = parts[2]

                            # Get detailed info
                            device_info = self._get_device_info(address)
                            devices.append(BluetoothDevice(
                                address=address,
                                name=name,
                                alias=device_info.get('alias', name),
                                paired=device_info.get('paired', False),
                                connected=device_info.get('connected', False),
                                trusted=device_info.get('trusted', False),
                                audio_sink=device_info.get('audio_sink', False)
                            ))

        except Exception as e:
            self.logger.error(f"Device discovery failed: {e}")

        return devices

    def _get_device_info(self, address: str) -> Dict[str, Any]:
        """Get detailed device information"""
        info = {}
        try:
            result = subprocess.run(['bluetoothctl', 'info', address],
                                  capture_output=True, text=True, timeout=5)

            if result.returncode == 0:
                for line in result.stdout.split('\n'):
                    line = line.strip()
                    if 'Paired: yes' in line:
                        info['paired'] = True
                    elif 'Connected: yes' in line:
                        info['connected'] = True
                    elif 'Trusted: yes' in line:
                        info['trusted'] = True
                    elif 'UUID: Audio Sink' in line:
                        info['audio_sink'] = True
                    elif 'Alias:' in line:
                        info['alias'] = line.split('Alias: ', 1)[1]

        except Exception as e:
            self.logger.debug(f"Failed to get device info for {address}: {e}")

        return info

    def find_sony_srs_x3(self) -> Optional[BluetoothDevice]:
        """Find the Sony SRS-X3 speaker specifically"""
        devices = self.discover_devices()

        for device in devices:
            if (device.address == self.SONY_SRS_X3_ADDRESS or
                self.SONY_SRS_X3_NAME in device.name):
                self.logger.info(f"Found Sony SRS-X3: {device}")
                return device

        self.logger.warning("Sony SRS-X3 not found in discovered devices")
        return None

    def connect_sony_srs_x3(self) -> bool:
        """Connect to Sony SRS-X3 speaker with full setup"""
        with self._connection_lock:
            try:
                self.connection_state = ConnectionState.CONNECTING
                self.logger.info("Attempting to connect to Sony SRS-X3...")

                # Step 1: Ensure device is paired and trusted
                if not self._ensure_device_setup(self.SONY_SRS_X3_ADDRESS):
                    self.connection_state = ConnectionState.FAILED
                    return False

                # Step 2: Connect to device
                if not self._connect_device(self.SONY_SRS_X3_ADDRESS):
                    self.connection_state = ConnectionState.FAILED
                    return False

                # Step 3: Wait for connection to stabilize
                time.sleep(2)

                # Step 4: Verify audio sink is available
                if not self._verify_audio_connection():
                    self.logger.warning("Audio connection not established, but device connected")

                # Step 5: Set as default audio output
                if not self._set_as_default_output():
                    self.logger.warning("Failed to set as default output, manual routing may be needed")

                self.connection_state = ConnectionState.CONNECTED
                self.logger.info("Successfully connected to Sony SRS-X3")
                return True

            except Exception as e:
                self.logger.error(f"Failed to connect to Sony SRS-X3: {e}")
                self.connection_state = ConnectionState.FAILED
                return False

    def _ensure_device_setup(self, address: str) -> bool:
        """Ensure device is paired and trusted"""
        try:
            # Trust device
            result = subprocess.run(['bluetoothctl', 'trust', address],
                                  capture_output=True, text=True, timeout=10)

            if result.returncode != 0:
                self.logger.warning(f"Trust command failed: {result.stderr}")

            # Pair if not already paired
            device_info = self._get_device_info(address)
            if not device_info.get('paired', False):
                self.logger.info("Pairing device...")
                result = subprocess.run(['bluetoothctl', 'pair', address],
                                      capture_output=True, text=True, timeout=15)

                if result.returncode != 0:
                    self.logger.error(f"Pairing failed: {result.stderr}")
                    return False

            return True

        except Exception as e:
            self.logger.error(f"Device setup failed: {e}")
            return False

    def _connect_device(self, address: str) -> bool:
        """Connect to Bluetooth device"""
        try:
            result = subprocess.run(['bluetoothctl', 'connect', address],
                                  capture_output=True, text=True, timeout=15)

            if result.returncode == 0:
                self.logger.info("Device connection successful")
                return True
            else:
                self.logger.error(f"Device connection failed: {result.stderr}")
                return False

        except Exception as e:
            self.logger.error(f"Connection attempt failed: {e}")
            return False

    def _verify_audio_connection(self) -> bool:
        """Verify audio sink is available"""
        try:
            # Try to detect if audio profile is connected
            device_info = self._get_device_info(self.SONY_SRS_X3_ADDRESS)
            return device_info.get('audio_sink', False)

        except Exception as e:
            self.logger.debug(f"Audio verification failed: {e}")
            return False

    def _set_as_default_output(self) -> bool:
        """Set Sony SRS-X3 as default audio output"""

        # Try wpctl first (PipeWire)
        if self._try_wpctl_set_default():
            self.active_audio_method = 'wpctl'
            return True

        # Try pactl (PulseAudio)
        if self._try_pactl_set_default():
            self.active_audio_method = 'pactl'
            return True

        # Fall back to ALSA device detection
        if self._detect_alsa_device():
            self.active_audio_method = 'aplay'
            return True

        self.logger.warning("Could not set as default output")
        return False

    def _try_wpctl_set_default(self) -> bool:
        """Try to set default using wpctl (PipeWire)"""
        try:
            # List sinks to find Bluetooth device
            result = subprocess.run(['wpctl', 'status'],
                                  capture_output=True, text=True, timeout=5)

            if result.returncode == 0:
                # Parse output to find Sony device
                for line in result.stdout.split('\n'):
                    if 'SONY' in line.upper() or 'SRS-X3' in line.upper():
                        # Extract sink ID (usually format: " * 123. Device Name")
                        parts = line.strip().split('.')
                        if len(parts) > 0:
                            sink_id = parts[0].replace('*', '').strip()
                            if sink_id.isdigit():
                                # Set as default
                                set_result = subprocess.run(['wpctl', 'set-default', sink_id],
                                                          capture_output=True, text=True, timeout=5)
                                if set_result.returncode == 0:
                                    self.logger.info(f"Set wpctl default sink to {sink_id}")
                                    return True

        except Exception as e:
            self.logger.debug(f"wpctl method failed: {e}")

        return False

    def _try_pactl_set_default(self) -> bool:
        """Try to set default using pactl (PulseAudio)"""
        try:
            # List sinks
            result = subprocess.run(['pactl', 'list', 'short', 'sinks'],
                                  capture_output=True, text=True, timeout=5)

            if result.returncode == 0:
                for line in result.stdout.split('\n'):
                    if 'sony' in line.lower() or 'srs-x3' in line.lower():
                        sink_name = line.split()[1]

                        # Set as default
                        set_result = subprocess.run(['pactl', 'set-default-sink', sink_name],
                                                  capture_output=True, text=True, timeout=5)
                        if set_result.returncode == 0:
                            self.logger.info(f"Set pactl default sink to {sink_name}")
                            return True

        except Exception as e:
            self.logger.debug(f"pactl method failed: {e}")

        return False

    def _detect_alsa_device(self) -> bool:
        """Detect ALSA device for Sony SRS-X3"""
        try:
            # List ALSA devices
            result = subprocess.run(['aplay', '-l'],
                                  capture_output=True, text=True, timeout=5)

            if result.returncode == 0:
                for line in result.stdout.split('\n'):
                    if 'sony' in line.lower() or 'bluetooth' in line.lower():
                        self.logger.info(f"Found potential ALSA device: {line}")
                        return True

        except Exception as e:
            self.logger.debug(f"ALSA detection failed: {e}")

        return False

    def disconnect_sony_srs_x3(self) -> bool:
        """Disconnect from Sony SRS-X3"""
        try:
            result = subprocess.run(['bluetoothctl', 'disconnect', self.SONY_SRS_X3_ADDRESS],
                                  capture_output=True, text=True, timeout=10)

            if result.returncode == 0:
                self.connection_state = ConnectionState.DISCONNECTED
                self.logger.info("Successfully disconnected from Sony SRS-X3")
                return True
            else:
                self.logger.error(f"Disconnection failed: {result.stderr}")
                return False

        except Exception as e:
            self.logger.error(f"Disconnection attempt failed: {e}")
            return False

    def is_connected(self) -> bool:
        """Check if Sony SRS-X3 is connected"""
        device_info = self._get_device_info(self.SONY_SRS_X3_ADDRESS)
        connected = device_info.get('connected', False)

        if connected:
            self.connection_state = ConnectionState.CONNECTED
        else:
            self.connection_state = ConnectionState.DISCONNECTED

        return connected

    def get_audio_command_prefix(self) -> List[str]:
        """Get the appropriate audio command prefix for current setup"""
        if self.active_audio_method == 'wpctl':
            # PipeWire - use default sink
            return []  # No prefix needed, wpctl handles routing

        elif self.active_audio_method == 'pactl':
            # PulseAudio - use default sink
            return []  # No prefix needed, pactl handles routing

        elif self.active_audio_method == 'aplay':
            # ALSA - need to specify device
            return ['aplay', '-D', 'bluetooth']  # Generic Bluetooth device

        else:
            # Fallback to system default
            self.logger.warning("No audio method configured, using system default")
            return []

    def play_test_audio(self, audio_file: str) -> bool:
        """Play test audio through Sony SRS-X3"""
        try:
            if not self.is_connected():
                self.logger.error("Sony SRS-X3 not connected")
                return False

            cmd_prefix = self.get_audio_command_prefix()

            if cmd_prefix:
                # Use specific audio command
                cmd = cmd_prefix + [audio_file]
            else:
                # Use default aplay
                cmd = ['aplay', audio_file]

            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)

            if result.returncode == 0:
                self.logger.info("Test audio playback successful")
                return True
            else:
                self.logger.error(f"Audio playback failed: {result.stderr}")
                return False

        except Exception as e:
            self.logger.error(f"Test audio playback failed: {e}")
            return False

    def get_connection_status(self) -> Dict[str, Any]:
        """Get comprehensive connection status"""
        sony_device = self.find_sony_srs_x3()

        return {
            'device_found': sony_device is not None,
            'device_info': sony_device.__dict__ if sony_device else None,
            'connection_state': self.connection_state.value,
            'audio_method': self.active_audio_method,
            'dbus_available': PYDBUS_AVAILABLE,
            'adapter_available': self._bluetooth_adapter is not None
        }

# Convenience functions for integration with existing KLoROS code
def create_bluetooth_manager(logger: Optional[logging.Logger] = None) -> BluetoothAudioManager:
    """Create and return a BluetoothAudioManager instance"""
    return BluetoothAudioManager(logger)

def ensure_sony_connected(logger: Optional[logging.Logger] = None) -> bool:
    """Ensure Sony SRS-X3 is connected and set as default output"""
    manager = create_bluetooth_manager(logger)

    if manager.is_connected():
        if logger:
            logger.info("Sony SRS-X3 already connected")
        return True

    return manager.connect_sony_srs_x3()
