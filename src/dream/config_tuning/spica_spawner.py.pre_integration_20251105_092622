#!/usr/bin/env python3
"""
SPICA Instance Spawner for Config Tuning

Creates isolated filesystem clones to test configuration candidates
without touching the production system.
"""
import os
import json
import shutil
import subprocess
import time
import uuid
import hashlib
import logging
from pathlib import Path
from typing import Dict, Any, Optional
from dataclasses import dataclass, asdict

logger = logging.getLogger(__name__)

TEMPLATE_DIR = Path("/home/kloros/experiments/spica/template")
INSTANCES_DIR = Path("/home/kloros/experiments/spica/instances")
MAX_INSTANCES = 10  # Per retention policy
MAX_AGE_DAYS = 3


@dataclass
class SpicaInstance:
    """Represents an ephemeral SPICA test instance."""
    spica_id: str
    instance_dir: Path
    manifest: Dict[str, Any]
    created_at: float

    def destroy(self):
        """Remove instance directory."""
        if self.instance_dir.exists():
            shutil.rmtree(self.instance_dir)
            logger.info(f"Destroyed SPICA instance {self.spica_id}")


def prune_old_instances(max_instances: int = MAX_INSTANCES, max_age_days: int = MAX_AGE_DAYS):
    """
    Prune old SPICA instances per retention policy.

    Removes instances that are:
    - Older than max_age_days
    - Beyond max_instances limit (oldest first)
    """
    if not INSTANCES_DIR.exists():
        return

    instances = []
    for instance_dir in INSTANCES_DIR.iterdir():
        if not instance_dir.is_dir() or instance_dir.name == "instances":
            continue

        manifest_path = instance_dir / "manifest.json"
        if not manifest_path.exists():
            continue

        try:
            manifest = json.loads(manifest_path.read_text())
            spawned_at = manifest.get("spawned_at", "1970-01-01T00:00:00+00:00")
            # Parse ISO timestamp
            import datetime
            spawned_time = datetime.datetime.fromisoformat(spawned_at.replace('+00:00', '+00:00'))
            age_days = (datetime.datetime.now(datetime.timezone.utc) - spawned_time).days

            instances.append({
                "dir": instance_dir,
                "age_days": age_days,
                "spawned_at": spawned_time
            })
        except Exception as e:
            logger.warning(f"Failed to parse instance {instance_dir}: {e}")
            continue

    # Sort by age (oldest first)
    instances.sort(key=lambda x: x["spawned_at"])

    # Remove instances older than max_age_days
    for inst in instances:
        if inst["age_days"] > max_age_days:
            logger.info(f"Pruning instance {inst['dir'].name} (age: {inst['age_days']} days)")
            shutil.rmtree(inst["dir"])
            instances.remove(inst)

    # Remove excess instances beyond max_instances
    if len(instances) > max_instances:
        excess_count = len(instances) - max_instances
        for inst in instances[:excess_count]:
            logger.info(f"Pruning instance {inst['dir'].name} (exceeded max {max_instances} instances)")
            shutil.rmtree(inst["dir"])


def spawn_instance(candidate: Dict[str, float], parent_id: Optional[str] = None,
                  notes: str = "") -> SpicaInstance:
    """
    Spawn an ephemeral SPICA instance by cloning the template.

    Args:
        candidate: Configuration parameters to test
        parent_id: Optional parent instance ID for lineage tracking
        notes: Optional notes describing the experiment

    Returns:
        SpicaInstance with instance directory and metadata
    """
    # Prune old instances before spawning new one
    prune_old_instances()

    # Generate unique SPICA ID
    spica_id = f"spica-{uuid.uuid4().hex[:8]}"
    instance_dir = INSTANCES_DIR / spica_id

    logger.info(f"Spawning SPICA instance {spica_id} from template")

    # Clone template directory
    if not TEMPLATE_DIR.exists():
        raise RuntimeError(f"SPICA template directory not found: {TEMPLATE_DIR}")

    try:
        shutil.copytree(TEMPLATE_DIR, instance_dir, symlinks=False)
        logger.info(f"Cloned template to {instance_dir}")
    except Exception as e:
        raise RuntimeError(f"Failed to clone SPICA template: {e}")

    uv_path_str = shutil.which("uv")
    if uv_path_str:
        uv_path = Path(uv_path_str)
    else:
        common_locations = [
            Path.home() / ".local" / "bin" / "uv",
            Path.home() / ".cargo" / "bin" / "uv",
            Path("/home/kloros/.local/bin/uv"),
            Path("/home/kloros/.cargo/bin/uv"),
            Path("/usr/local/bin/uv"),
            Path("/usr/bin/uv")
        ]
        uv_path = next((p for p in common_locations if p.exists()), None)

    if not uv_path or not uv_path.exists():
        try:
            logger.info(f"Installing uv for {spica_id}")
            install_uv = subprocess.run(
                "curl -LsSf https://astral.sh/uv/install.sh | sh",
                shell=True,
                capture_output=True,
                text=True,
                timeout=120
            )
            if install_uv.returncode != 0:
                logger.warning(f"Failed to install uv: {install_uv.stderr}")
        except Exception as e:
            logger.warning(f"Failed to install uv: {e}")

    if uv_path and uv_path.exists():
        try:
            logger.info(f"Installing dependencies in {spica_id}")
            sync_result = subprocess.run(
                [str(uv_path), "sync"],
                cwd=instance_dir,
                capture_output=True,
                text=True,
                timeout=300
            )
            if sync_result.returncode != 0:
                logger.warning(f"Failed to sync dependencies: {sync_result.stderr}")
            else:
                logger.info(f"Successfully installed dependencies in {spica_id}")

                # Create .pth file to make spica/tools modules importable
                # Maturin editable installs don't create .pth files for Python source modules
                try:
                    site_packages = instance_dir / ".venv" / "lib" / "python3.10" / "site-packages"
                    pth_file = site_packages / f"{spica_id}-source.pth"
                    pth_file.write_text(str(instance_dir) + "\n")
                    logger.info(f"Created .pth file for Python modules in {spica_id}")
                except Exception as e:
                    logger.warning(f"Failed to create .pth file: {e}")
        except Exception as e:
            logger.warning(f"Failed to sync dependencies: {e}")
    else:
        logger.warning(f"uv not found in PATH or common locations, skipping dependency installation")

    # Get git commit from template
    try:
        result = subprocess.run(
            ['git', 'rev-parse', '--short', 'HEAD'],
            cwd=TEMPLATE_DIR,
            capture_output=True,
            text=True,
            timeout=5
        )
        template_commit = result.stdout.strip() if result.returncode == 0 else "unknown"
    except:
        template_commit = "unknown"

    # Create manifest
    import datetime
    spawned_at = datetime.datetime.now(datetime.timezone.utc).isoformat()

    manifest = {
        "schema": "spica.manifest/v1",
        "spica_id": spica_id,
        "template_ref": f"git:{template_commit}",
        "template_version": "0.1.0",
        "lineage_sha": hashlib.sha256(json.dumps(candidate, sort_keys=True).encode()).hexdigest(),
        "seed": int(time.time()),
        "params": candidate,
        "budget": {
            "cpu": 4,
            "ram_gb": 8,
            "vram_gb": 8
        },
        "spawned_at": spawned_at,
        "notes": notes or "ConfigTuning auto-spawn"
    }

    manifest_path = instance_dir / "manifest.json"
    manifest_path.write_text(json.dumps(manifest, indent=2))

    # Create lineage
    lineage = {
        "spica_id": spica_id,
        "parent_id": parent_id,
        "origin_commit": template_commit,
        "generation": 0,
        "spawned_at": spawned_at
    }

    lineage_path = instance_dir / "lineage.json"
    lineage_path.write_text(json.dumps(lineage, indent=2))

    # Create .env.spica with candidate configuration
    canary_mode = os.environ.get("KLR_CANARY_MODE", "predictive")
    canary_port = os.environ.get("KLR_CANARY_PORT", "9011")

    env_content = f"""# SPICA Instance Environment Configuration
# Auto-generated for {spica_id}

# Intra-instance promotion: DISABLED
SPICA_INTRA_PROMOTE=0

# Auto-promote to KLoROS: ALWAYS 0 (only D-REAM can promote to production)
SPICA_AUTOPROMOTE_TO_KLOROS=0

# Telemetry & observability
SPICA_TELEMETRY_TRACE=1

# Security: Network lockdown
SPICA_NET_EGRESS=0

# Resource budgets (CPU, RAM, VRAM in GB)
SPICA_BUDGET_CPU=4
SPICA_BUDGET_RAM_GB=8
SPICA_BUDGET_VRAM_GB=8

# Canary testing mode (inherited from parent)
KLR_CANARY_MODE={canary_mode}
KLR_CANARY_PORT={canary_port}

# Candidate configuration parameters
"""

    # Add candidate parameters to environment
    for key, value in candidate.items():
        # Convert parameter names to environment variables
        # e.g., "vllm.gpu_memory_utilization" -> "VLLM_GPU_MEMORY_UTILIZATION"
        env_key = key.upper().replace(".", "_")
        env_content += f"{env_key}={value}\n"

    env_path = instance_dir / ".env.spica"
    env_path.write_text(env_content)

    logger.info(f"SPICA instance {spica_id} spawned successfully")

    return SpicaInstance(
        spica_id=spica_id,
        instance_dir=instance_dir,
        manifest=manifest,
        created_at=time.time()
    )


def run_test_in_instance(instance: SpicaInstance, test_script: str, timeout_sec: int = 300) -> Dict[str, Any]:
    """
    Run a test script inside the SPICA instance.

    Args:
        instance: SPICA instance to run test in
        test_script: Python script to execute
        timeout_sec: Maximum execution time

    Returns:
        Dict with test results (stdout, stderr, returncode, metrics)
    """
    logger.info(f"Running test in SPICA instance {instance.spica_id}")

    # Create a test runner script
    runner_script = instance.instance_dir / "test_runner.py"
    runner_script.write_text(test_script)

    # Set up environment for isolated execution
    env = os.environ.copy()
    env['SPICA_INSTANCE_ID'] = instance.spica_id
    env['SPICA_ISOLATED'] = '1'

    # Load .env.spica into environment
    env_file = instance.instance_dir / ".env.spica"
    if env_file.exists():
        for line in env_file.read_text().splitlines():
            line = line.strip()
            if line and not line.startswith('#') and '=' in line:
                key, value = line.split('=', 1)
                env[key] = value

    try:
        result = subprocess.run(
            ['/home/kloros/.venv/bin/python3', str(runner_script)],
            cwd=instance.instance_dir,
            env=env,
            capture_output=True,
            text=True,
            timeout=timeout_sec
        )

        return {
            "stdout": result.stdout,
            "stderr": result.stderr,
            "returncode": result.returncode,
            "success": result.returncode == 0,
            "timeout": False
        }
    except subprocess.TimeoutExpired:
        logger.error(f"Test timed out after {timeout_sec}s in instance {instance.spica_id}")
        return {
            "stdout": "",
            "stderr": f"Test timed out after {timeout_sec}s",
            "returncode": 124,
            "success": False,
            "timeout": True
        }
    except Exception as e:
        logger.error(f"Test execution failed in instance {instance.spica_id}: {e}")
        return {
            "stdout": "",
            "stderr": str(e),
            "returncode": 1,
            "success": False,
            "timeout": False
        }
    finally:
        # Clean up runner script
        if runner_script.exists():
            runner_script.unlink()


def apply_code_patch(
    instance_dir: Path,
    target_file: Path,
    patch_content: str
) -> bool:
    try:
        resolved_target = (instance_dir / target_file).resolve()

        if not str(resolved_target).startswith(str(instance_dir.resolve())):
            logger.error(f"Path traversal attempt blocked: {target_file}")
            return False

        resolved_target.parent.mkdir(parents=True, exist_ok=True)

        resolved_target.write_text(patch_content)
        logger.info(f"Applied patch to {target_file} in {instance_dir.name}")
        return True

    except Exception as e:
        logger.error(f"Failed to apply patch to {target_file}: {e}")
        return False


def run_tests_in_instance(
    instance_dir: Path,
    test_command: str,
    timeout: int = 300
) -> Dict:
    try:
        result = subprocess.run(
            test_command,
            shell=True,
            cwd=instance_dir,
            capture_output=True,
            text=True,
            timeout=timeout
        )

        return {
            "success": result.returncode == 0,
            "output": result.stdout + result.stderr,
            "returncode": result.returncode
        }

    except subprocess.TimeoutExpired:
        logger.error(f"Test command timed out after {timeout}s")
        return {
            "success": False,
            "output": f"Test timed out after {timeout}s",
            "returncode": -1
        }
    except Exception as e:
        logger.error(f"Failed to run tests: {e}")
        return {
            "success": False,
            "output": str(e),
            "returncode": -1
        }
