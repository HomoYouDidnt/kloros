#!/usr/bin/env python3
"""
PHASE Trigger - Wrapper for running PHASE with signal handling.

Executes PHASE test runs and verifies completion signals with SHA256 validation.
"""

import os
import json
import hashlib
import subprocess
import time
import logging
from pathlib import Path
from dataclasses import dataclass
from typing import Optional

from .state_manager import acquire, release

logger = logging.getLogger(__name__)

SIGNAL_TMP = Path("/tmp")
SIGNAL_HOME = Path("/home/kloros/.kloros/signals")
PHASE_TIMEOUT_S = 60 * 60  # 1 hour default


@dataclass
class PhaseResult:
    """Result of PHASE execution."""
    exit_code: int
    epoch_id: str
    report_path: Optional[Path]
    signal_path: Optional[Path]
    sha256: Optional[str]
    duration_s: float


def run_epoch(force: bool = False, epoch_id: Optional[str] = None, timeout_s: int = PHASE_TIMEOUT_S) -> PhaseResult:
    """
    Run a PHASE epoch with lock protection and signal verification.

    Args:
        force: Force run even if already completed today
        epoch_id: Specific epoch ID (default: auto-generated by PHASE)
        timeout_s: Maximum execution time (default: 1 hour)

    Returns:
        PhaseResult with execution details

    Raises:
        RuntimeError: If PHASE execution fails or signals are invalid
    """
    lock = acquire("phase")
    start_time = time.time()

    try:
        # Build command
        cmd = ["python3", "-m", "src.phase.run_all_domains"]
        if force:
            cmd.append("--force")
        if epoch_id:
            cmd.extend(["--epoch-id", epoch_id])

        logger.info(f"Starting PHASE epoch (timeout={timeout_s}s)")

        # Execute PHASE
        result = subprocess.run(
            cmd,
            cwd="/home/kloros",
            capture_output=True,
            text=True,
            timeout=timeout_s
        )

        duration_s = time.time() - start_time

        if result.returncode != 0:
            logger.error(f"PHASE failed with exit code {result.returncode}")
            logger.error(f"STDOUT: {result.stdout}")
            logger.error(f"STDERR: {result.stderr}")
            return PhaseResult(
                exit_code=result.returncode,
                epoch_id=epoch_id or "unknown",
                report_path=None,
                signal_path=None,
                sha256=None,
                duration_s=duration_s
            )

        # Extract epoch_id from output or signals
        detected_epoch_id = _extract_epoch_id(result.stdout, result.stderr)
        if not detected_epoch_id:
            logger.warning("Could not detect epoch_id from PHASE output")
            detected_epoch_id = epoch_id or "unknown"

        # Wait briefly for signal files to appear
        time.sleep(1)

        # Look for completion signals
        touch_file = SIGNAL_TMP / f"klr_phase_complete_{detected_epoch_id}"
        signal_file = SIGNAL_HOME / f"klr_phase_complete_{detected_epoch_id}.json"

        if not touch_file.exists():
            logger.error(f"Touch signal file not found: {touch_file}")
            return PhaseResult(
                exit_code=1,
                epoch_id=detected_epoch_id,
                report_path=None,
                signal_path=None,
                sha256=None,
                duration_s=duration_s
            )

        if not signal_file.exists():
            logger.error(f"JSON signal file not found: {signal_file}")
            return PhaseResult(
                exit_code=1,
                epoch_id=detected_epoch_id,
                report_path=None,
                signal_path=None,
                sha256=None,
                duration_s=duration_s
            )

        # Parse and verify signal
        with open(signal_file, 'r') as f:
            signal_data = json.load(f)

        report_path = Path(signal_data.get("report", ""))
        expected_sha = signal_data.get("sha256", "")

        if not report_path.exists():
            logger.error(f"Report file not found: {report_path}")
            return PhaseResult(
                exit_code=1,
                epoch_id=detected_epoch_id,
                report_path=None,
                signal_path=signal_file,
                sha256=None,
                duration_s=duration_s
            )

        # Verify SHA256
        actual_sha = hashlib.sha256(report_path.read_bytes()).hexdigest()
        if actual_sha != expected_sha:
            logger.error(f"SHA256 mismatch! Expected {expected_sha}, got {actual_sha}")
            return PhaseResult(
                exit_code=1,
                epoch_id=detected_epoch_id,
                report_path=report_path,
                signal_path=signal_file,
                sha256=actual_sha,
                duration_s=duration_s
            )

        logger.info(f"PHASE epoch {detected_epoch_id} completed successfully in {duration_s:.1f}s")

        return PhaseResult(
            exit_code=0,
            epoch_id=detected_epoch_id,
            report_path=report_path.resolve(),
            signal_path=signal_file.resolve(),
            sha256=actual_sha,
            duration_s=duration_s
        )

    except subprocess.TimeoutExpired:
        logger.error(f"PHASE timeout after {timeout_s}s")
        return PhaseResult(
            exit_code=124,  # Standard timeout exit code
            epoch_id=epoch_id or "timeout",
            report_path=None,
            signal_path=None,
            sha256=None,
            duration_s=time.time() - start_time
        )
    except Exception as e:
        logger.error(f"PHASE execution error: {e}")
        return PhaseResult(
            exit_code=1,
            epoch_id=epoch_id or "error",
            report_path=None,
            signal_path=None,
            sha256=None,
            duration_s=time.time() - start_time
        )
    finally:
        release(lock)


def _extract_epoch_id(stdout: str, stderr: str) -> Optional[str]:
    """Extract epoch_id from PHASE output."""
    combined = stdout + "\n" + stderr

    # Look for patterns like "epoch_id: 20251028_..." or similar
    import re
    patterns = [
        r'epoch[_-]id[:\s]+([a-zA-Z0-9_-]+)',
        r'Epoch:\s+([a-zA-Z0-9_-]+)',
        r'klr_phase_complete_([a-zA-Z0-9_-]+)',
    ]

    for pattern in patterns:
        match = re.search(pattern, combined, re.IGNORECASE)
        if match:
            return match.group(1)

    return None
