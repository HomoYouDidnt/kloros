#!/home/kloros/.venv/bin/python3
"""
Extended klorosctl with wiki commands.

This is a wrapper that adds wiki commands to the existing klorosctl CLI.
"""

import sys

sys.path.insert(0, "/home/kloros/src")

from kloros.registry.lifecycle_registry import LifecycleRegistry
from wiki.cli_commands import main as wiki_main
import argparse
import json
import time
import logging

logging.basicConfig(level=logging.INFO, format="%(message)s")
logger = logging.getLogger(__name__)


class KLoROSCtl:
    """KLoROS control command-line interface."""

    def __init__(self):
        self.registry = LifecycleRegistry()

    def promote_cohort(
        self,
        cohort: int,
        to_state: str,
        reason: str,
        dry_run: bool = False,
    ) -> int:
        """
        Promote all zooids in a cohort to a new lifecycle state.

        Args:
            cohort: Cohort number (1, 2, etc.)
            to_state: Target state (PROBATION, ACTIVE, PRIMARY)
            reason: Reason for promotion
            dry_run: If True, show what would be done without doing it

        Returns:
            0 on success, 1 on failure
        """
        cohort_niches = {
            1: ["maintenance_housekeeping", "observability_logging"],
            2: ["resource_monitoring", "error_recovery"],
        }

        if cohort not in cohort_niches:
            logger.error(f"Unknown cohort: {cohort}")
            return 1

        niches = cohort_niches[cohort]

        logger.info(f"{'[DRY RUN] ' if dry_run else ''}Promoting Cohort {cohort} to {to_state}")
        logger.info(f"  Niches: {', '.join(niches)}")
        logger.info(f"  Reason: {reason}")
        logger.info("")

        with self.registry.lock():
            reg = self.registry.load()

            for niche in niches:
                niche_zooids = [
                    name for name, zooid in reg["zooids"].items()
                    if zooid.get("niche") == niche
                ]

                if not niche_zooids:
                    logger.warning(f"  ⚠️  No zooids found for niche: {niche}")
                    continue

                for zooid_name in niche_zooids:
                    zooid = reg["zooids"][zooid_name]
                    old_state = zooid.get("lifecycle_state", "UNKNOWN")

                    logger.info(f"  {zooid_name}: {old_state} → {to_state}")

                    if not dry_run:
                        zooid["lifecycle_state"] = to_state
                        zooid["last_promotion"] = {
                            "timestamp": time.time(),
                            "from_state": old_state,
                            "to_state": to_state,
                            "reason": reason,
                        }

                        old_state_lower = old_state.lower() if old_state else "unknown"
                        new_state_lower = to_state.lower()

                        if niche in reg["niches_by_state"].get(old_state_lower, {}):
                            if zooid_name in reg["niches_by_state"][old_state_lower][niche]:
                                reg["niches_by_state"][old_state_lower][niche].remove(zooid_name)

                        self.registry.index_add(reg, niche, new_state_lower, zooid_name)

            if not dry_run:
                self.registry.snapshot_then_atomic_write(reg)
                logger.info(f"\n✅ Registry updated to version {reg['version']}")
            else:
                logger.info(f"\n[DRY RUN] Registry would be updated (current version: {reg['version']})")

        return 0

    def status_cohort(self, cohort: int) -> int:
        """Show status of all zooids in a cohort."""
        cohort_niches = {
            1: ["maintenance_housekeeping", "observability_logging"],
            2: ["resource_monitoring", "error_recovery"],
        }

        if cohort not in cohort_niches:
            logger.error(f"Unknown cohort: {cohort}")
            return 1

        niches = cohort_niches[cohort]

        logger.info(f"Cohort {cohort} Status")
        logger.info("=" * 80)

        with self.registry.lock():
            reg = self.registry.load()

            for niche in niches:
                logger.info(f"\n{niche}:")

                niche_zooids = [
                    (name, zooid) for name, zooid in reg["zooids"].items()
                    if zooid.get("niche") == niche
                ]

                if not niche_zooids:
                    logger.info("  No zooids registered")
                    continue

                for zooid_name, zooid in niche_zooids:
                    state = zooid.get("lifecycle_state", "UNKNOWN")
                    generation = zooid.get("generation", "?")
                    fitness = zooid.get("fitness_score", 0.0)

                    logger.info(f"  {zooid_name}")
                    logger.info(f"    State: {state}")
                    logger.info(f"    Generation: {generation}")
                    logger.info(f"    Fitness: {fitness:.4f}")

                    if "last_promotion" in zooid:
                        promo = zooid["last_promotion"]
                        timestamp = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(promo["timestamp"]))
                        logger.info(f"    Last Promotion: {promo['from_state']} → {promo['to_state']} ({timestamp})")

        logger.info("\n" + "=" * 80)
        return 0


def main():
    """Main entry point for klorosctl."""
    parser = argparse.ArgumentParser(description="KLoROS Control CLI")
    subparsers = parser.add_subparsers(dest="command", help="Command to execute")

    promote_parser = subparsers.add_parser("promote", help="Promote zooids through lifecycle states")
    promote_parser.add_argument("--cohort", type=int, required=True, help="Cohort number (1, 2, etc.)")
    promote_parser.add_argument("--to", dest="to_state", required=True, help="Target state (PROBATION, ACTIVE, PRIMARY)")
    promote_parser.add_argument("--reason", default="Manual promotion", help="Reason for promotion")
    promote_parser.add_argument("--dry-run", action="store_true", help="Show what would be done without doing it")

    status_parser = subparsers.add_parser("status", help="Show zooid status")
    status_parser.add_argument("--cohort", type=int, required=True, help="Cohort number (1, 2, etc.)")

    wiki_parser = subparsers.add_parser("wiki", help="Wiki operations")
    wiki_subparsers = wiki_parser.add_subparsers(dest="wiki_command", help="Wiki command to execute")

    wiki_sync_parser = wiki_subparsers.add_parser("sync", help="Sync wiki: run indexer and docgen")
    wiki_status_parser = wiki_subparsers.add_parser("status", help="Show wiki status")
    wiki_show_parser = wiki_subparsers.add_parser("show", help="Show capability")
    wiki_show_parser.add_argument("target", choices=["capability"], help="What to show")
    wiki_show_parser.add_argument("id", help="Capability ID")

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        return 1

    ctl = KLoROSCtl()

    if args.command == "promote":
        return ctl.promote_cohort(
            cohort=args.cohort,
            to_state=args.to_state,
            reason=args.reason,
            dry_run=args.dry_run,
        )
    elif args.command == "status":
        return ctl.status_cohort(cohort=args.cohort)
    elif args.command == "wiki":
        if args.wiki_command == "sync":
            sys.argv = ["wiki.cli_commands", "sync"]
            return wiki_main()
        elif args.wiki_command == "status":
            sys.argv = ["wiki.cli_commands", "status"]
            return wiki_main()
        elif args.wiki_command == "show":
            sys.argv = ["wiki.cli_commands", "show", args.target, args.id]
            return wiki_main()
        else:
            logger.error("Unknown wiki command")
            return 1
    else:
        logger.error(f"Unknown command: {args.command}")
        return 1


if __name__ == "__main__":
    sys.exit(main())
