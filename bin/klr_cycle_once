#!/usr/bin/env python3
"""
Execute one lifecycle cycle (called by systemd timer).
"""
import sys
import time
from pathlib import Path

sys.path.insert(0, str(Path.home() / "src"))

from kloros.registry.lifecycle_registry import LifecycleRegistry
from kloros.orchestration.cycle_coordinator import cycle_once
from kloros.phase.graduator import run_graduations
from kloros.dream.bioreactor import bioreactor_tick
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Placeholder implementations for now
def mock_start_service(zooid_name: str) -> bool:
    logger.info(f"[MOCK] Would start systemd service for {zooid_name}")
    return True

def mock_wait_for_heartbeat(zooid_name: str, timeout_sec: int) -> bool:
    logger.info(f"[MOCK] Would wait for heartbeat from {zooid_name}")
    return True

def mock_differentiate(genome_str: str, niche: str, m: int):
    logger.info(f"[MOCK] Would differentiate {m} candidates")
    return []

def mock_select_winners(defenders, candidates, fitness_rows):
    logger.info(f"[MOCK] Would run tournament")
    return []

def mock_enqueue_phase(candidate: dict):
    logger.info(f"[MOCK] Would enqueue {candidate.get('zooid_name')} to PHASE")

def main():
    reg_mgr = LifecycleRegistry()
    now = time.time()

    try:
        stats = cycle_once(
            now=now,
            registry_load=reg_mgr.load,
            registry_lock=reg_mgr.lock,
            registry_write=lambda reg: reg_mgr.snapshot_then_atomic_write(reg),
            bioreactor_tick=lambda reg, eco, niche, prod_rows, phase_rows, now: bioreactor_tick(
                reg=reg,
                ecosystem=eco,
                niche=niche,
                prod_rows=prod_rows,
                phase_rows=phase_rows,
                now=now,
                differentiate=mock_differentiate,
                select_winners=mock_select_winners,
                enqueue_phase_candidate=mock_enqueue_phase
            ),
            start_probation_batch=lambda reg, candidates, now, on_event: [],
            discover_dormant=lambda reg: [],
            run_graduations=lambda reg, now, on_event: run_graduations(
                reg=reg,
                now=now,
                start_service=mock_start_service,
                wait_for_heartbeat=mock_wait_for_heartbeat,
                on_event=on_event
            ),
            on_event=lambda e: logger.info(f"Event: {e.get('event_type', 'unknown')}"),
            tz="UTC"
        )

        logger.info(f"Cycle stats: {stats}")
        return 0

    except Exception as e:
        logger.error(f"Cycle failed: {e}", exc_info=True)
        return 1

if __name__ == "__main__":
    sys.exit(main())
