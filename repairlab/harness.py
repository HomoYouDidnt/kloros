"""CLI harness for generating bug-injected test bundles."""
import argparse
import json
import random
import shutil
from pathlib import Path
from .injector import inject_bug, list_bugs


def load_source(src_path: Path) -> str:
    """Load source code from file."""
    return src_path.read_text(encoding="utf-8")


def write_bundle(out: Path, mutated_source: str, bug_id: str, description: str, 
                 difficulty: str, seed: int):
    """Write complete test bundle with mutated code, tests, and manifest."""
    # Create output structure
    (out / "repairlab" / "samples").mkdir(parents=True, exist_ok=True)
    (out / "tests").mkdir(parents=True, exist_ok=True)
    
    # Write __init__.py files
    (out / "repairlab" / "__init__.py").write_text("", encoding="utf-8")
    (out / "repairlab" / "samples" / "__init__.py").write_text("", encoding="utf-8")
    
    # Write mutated module
    (out / "repairlab" / "samples" / "sum_list.py").write_text(
        mutated_source, encoding="utf-8"
    )
    
    # Copy tests from source, fix path for bundle structure
    src_test_path = Path("/home/kloros/repairlab/tests/test_sum_list.py")
    if src_test_path.exists():
        test_content = src_test_path.read_text(encoding="utf-8")
        # Fix sys.path manipulation for bundle (needs .parent.parent not .parent.parent.parent)
        test_content = test_content.replace(
            "sys.path.insert(0, str(Path(__file__).parent.parent.parent))",
            "sys.path.insert(0, str(Path(__file__).parent.parent))"
        )
        (out / "tests" / "test_sum_list.py").write_text(test_content, encoding="utf-8")
    
    # Create manifest
    manifest = {
        "bug_id": bug_id,
        "bug_description": description,
        "difficulty": difficulty,
        "seed": seed,
        "target_module": "repairlab/samples/sum_list.py",
        "test_file": "tests/test_sum_list.py",
        "failing_tests": [
            "tests/test_sum_list.py::test_sum_inclusive_small",
            "tests/test_sum_list.py::test_sum_inclusive_larger",
            "tests/test_sum_list.py::test_mean_basic",
            "tests/test_sum_list.py::test_count_evens_basic",
            "tests/test_sum_list.py::test_fibonacci_small",
        ],
        "notes": "Auto-generated by repairlab.harness; tests should fail pre-repair."
    }
    
    (out / "defect_manifest.json").write_text(
        json.dumps(manifest, indent=2), encoding="utf-8"
    )
    
    # Create README
    readme = f"""# Bug Injection Test Bundle

**Bug ID:** `{bug_id}`
**Difficulty:** {difficulty}
**Description:** {description}
**Seed:** {seed}

## Usage

1. Run tests (should fail):
   ```bash
   cd {out}
   pytest -v tests/
   ```

2. Fix the bug in `repairlab/samples/sum_list.py`

3. Re-run tests (should pass):
   ```bash
   pytest -v tests/
   ```

## Manifest

See `defect_manifest.json` for complete bug metadata.
"""
    
    (out / "README.md").write_text(readme, encoding="utf-8")


def main():
    """Main CLI entry point."""
    ap = argparse.ArgumentParser(
        description="Generate bug-injected test bundles for code repair testing"
    )
    ap.add_argument("--seed", type=int, default=1337,
                    help="Random seed for deterministic bug selection")
    ap.add_argument("--out", type=Path,
                    help="Output directory for test bundle")
    ap.add_argument("--difficulty", choices=["easy", "medium", "hard"],
                    help="Filter bugs by difficulty")
    ap.add_argument("--list-bugs", action="store_true",
                    help="List all available bugs and exit")

    args = ap.parse_args()

    if args.list_bugs:
        list_bugs()
        return

    if not args.out:
        ap.error("--out is required when generating bundles")
    
    # Load source code
    rng = random.Random(args.seed)
    src_path = Path("/home/kloros/repairlab/samples/sum_list.py")
    
    if not src_path.exists():
        print(f"Error: Source file not found: {src_path}")
        return 1
    
    source = load_source(src_path)
    
    # Inject bug
    try:
        inj = inject_bug(source, rng, args.difficulty)
    except RuntimeError as e:
        print(f"Error: {e}")
        return 1
    
    # Clean and create output directory
    if args.out.exists():
        shutil.rmtree(args.out)
    args.out.mkdir(parents=True, exist_ok=True)
    
    # Write bundle
    write_bundle(
        args.out,
        inj.mutated_source,
        inj.bug_id,
        inj.description,
        inj.difficulty,
        args.seed
    )
    
    print(f"[OK] Created bundle at {args.out}")
    print(f"     Bug: {inj.bug_id} ({inj.difficulty})")
    print(f"     Description: {inj.description}")
    print(f"\nNext steps:")
    print(f"  cd {args.out}")
    print(f"  pytest -v tests/  # Should fail")
    
    return 0


if __name__ == "__main__":
    import sys
    sys.exit(main())
